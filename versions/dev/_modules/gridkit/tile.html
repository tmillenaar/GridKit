

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gridkit.tile &mdash; GridKit dev documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-binder.css?v=f4aeca0c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />

  
    <link rel="canonical" href="https://tmilenaar.github.io/GridKit/versions/dev/_modules/gridkit/tile.html" />
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=3ce10a4d"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            GridKit
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example_gallery/index.html">Example Gallery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roadmap.html">Roadmap</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_notes.html">Release notes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">GridKit</a>
      </nav>

      <div class="wy-nav-content">
  
    <div style="
        background-color: #f5dfed;
        color:#2d2c2e;
        padding: 1em;
        border-bottom: 2px solid #ecacfa;
        font-weight: bold;
        text-align: center;
    ">
      You are viewing the <strong>development version</strong> of the documentation (dev).<br>
      This is the bleeding edge. Changes might not yet be released and may be changed or reverted.
    </div>
  
  
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gridkit.tile</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gridkit.tile</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyproj</span><span class="w"> </span><span class="kn">import</span> <span class="n">Transformer</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">shapely.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">MultiPoint</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">gridkit.base_grid</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseGrid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gridkit.errors</span><span class="w"> </span><span class="kn">import</span> <span class="n">AlignmentError</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gridkit.gridkit_rs</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gridkit.hex_grid</span><span class="w"> </span><span class="kn">import</span> <span class="n">HexGrid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gridkit.index</span><span class="w"> </span><span class="kn">import</span> <span class="n">GridIndex</span><span class="p">,</span> <span class="n">validate_index</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gridkit.rect_grid</span><span class="w"> </span><span class="kn">import</span> <span class="n">RectGrid</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">gridkit.tri_grid</span><span class="w"> </span><span class="kn">import</span> <span class="n">TriGrid</span>


<div class="viewcode-block" id="get_value_dtype">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.get_value_dtype">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_value_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">generic</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span></div>



<div class="viewcode-block" id="Tile">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Tile</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Tile describes a set of cells defined by the ``start_id``,</span>
<span class="sd">    which is the cell that defines the bottom-left corner of the tile,</span>
<span class="sd">    and ``nx`` and ``ny``, which are the number of cells in the x and y directions, respectively.</span>

<span class="sd">    Each tile is associated with a particular grid and the Tile refers to a selection</span>
<span class="sd">    of grid indices on that grid. The associated grid can be accessed using the ``.grid`` property.</span>

<span class="sd">    .. Note ::</span>

<span class="sd">        ``nx`` and ``ny`` can be seen as &#39;right&#39; and &#39;up&#39;, respectively, when the rotation of the grid is zero.</span>
<span class="sd">        If the grid is rotated, the tile rotates with it (naturally).</span>
<span class="sd">        This means that for a grid that is rotated 90 degrees,</span>
<span class="sd">        ``nx`` refers to the number of cells up, and ``ny`` refers to the number of cells to the left.</span>

<span class="sd">    ..</span>

<span class="sd">    Init parameters</span>
<span class="sd">    ---------------</span>
<span class="sd">    grid: :class:`.BaseGrid`</span>
<span class="sd">        The :class:`.TriGrid`, :class:`.RectGrid` or :class:`.HexGrid` the tile is associated with</span>
<span class="sd">    start_id: Union[Tuple[int, int], GridIndex]</span>
<span class="sd">        The starting cell of the Tile.</span>
<span class="sd">        The starting cell defines the bottom-left corner of the Tile if the associated grid is not rotated.</span>
<span class="sd">    nx: int</span>
<span class="sd">        The number of cells in x direction, starting from the ``start_id``</span>
<span class="sd">    ny: int</span>
<span class="sd">        The number of cells in y direction, starting from the ``start_id``</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grid</span><span class="p">:</span> <span class="n">BaseGrid</span><span class="p">,</span>
        <span class="n">start_id</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">GridIndex</span><span class="p">],</span>
        <span class="n">nx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">ny</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">nx</span> <span class="o">%</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected an integer for &#39;nx&#39;, got: </span><span class="si">{</span><span class="n">nx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nx</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected &#39;nx&#39; to be 1 or larger, got: </span><span class="si">{</span><span class="n">nx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">ny</span> <span class="o">%</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected an integer for &#39;ny&#39;, got: </span><span class="si">{</span><span class="n">ny</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ny</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected &#39;nx&#39; to be 1 or larger, got: </span><span class="si">{</span><span class="n">ny</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">GridIndex</span><span class="p">(</span><span class="n">start_id</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;start_id&#39; must be a single pair of indices in the form (x,y), got: </span><span class="si">{start_id}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">start_id</span> <span class="o">=</span> <span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">start_id</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_id</span><span class="p">,</span> <span class="n">GridIndex</span><span class="p">)</span>
            <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">start_id</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">TriGrid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tile</span> <span class="o">=</span> <span class="n">PyO3Tile</span><span class="o">.</span><span class="n">from_tri_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">_grid</span><span class="p">,</span> <span class="n">start_id</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">RectGrid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tile</span> <span class="o">=</span> <span class="n">PyO3Tile</span><span class="o">.</span><span class="n">from_rect_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">_grid</span><span class="p">,</span> <span class="n">start_id</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">HexGrid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_tile</span> <span class="o">=</span> <span class="n">PyO3Tile</span><span class="o">.</span><span class="n">from_hex_grid</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">_grid</span><span class="p">,</span> <span class="n">start_id</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected type for &#39;grid&#39;, expected a TriGrid, RectGrid or HexGrid, got a: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

<div class="viewcode-block" id="Tile.from_pyo3_tile">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.from_pyo3_tile">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_pyo3_tile</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pyo3_tile</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tile</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pyo3_tile</span><span class="o">.</span><span class="n">start_id</span><span class="p">,</span> <span class="n">pyo3_tile</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="n">pyo3_tile</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tile.to_data_tile">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.to_data_tile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Setting data is only allowed for 2D data. Got data with </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The provided data has </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> elements in the first axis but the tile has </span><span class="si">{</span><span class="n">tile</span><span class="o">.</span><span class="n">ny</span><span class="si">}</span><span class="s2"> y-elements. Beware that a numpy array&#39;s axis order is in y,x.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The provided data has </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> elements in the second axis but the tile has </span><span class="si">{</span><span class="n">tile</span><span class="o">.</span><span class="n">nx</span><span class="si">}</span><span class="s2"> x-elements. Beware that a numpy array&#39;s axis order is in y,x.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">nodata_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Subtract one form default max value because some large values</span>
                <span class="c1"># that are acceptable values to numpy is too large for rasterio.</span>
                <span class="c1"># nodata_value = numpy.iinfo(data.dtype).max - 512</span>
                <span class="n">nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="o">-</span> <span class="mi">1024</span>

        <span class="k">return</span> <span class="n">DataTile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">nodata_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tile.to_data_tile_with_value">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.to_data_tile_with_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_data_tile_with_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">get_value_dtype</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nodata_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>

        <span class="c1"># Map numpy dtypes to method suffixes</span>
        <span class="n">dtype_method_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">):</span> <span class="s2">&quot;f64&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">):</span> <span class="s2">&quot;f32&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">):</span> <span class="s2">&quot;i64&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">):</span> <span class="s2">&quot;i32&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int16&quot;</span><span class="p">):</span> <span class="s2">&quot;i16&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int8&quot;</span><span class="p">):</span> <span class="s2">&quot;i8&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint64&quot;</span><span class="p">):</span> <span class="s2">&quot;u64&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint32&quot;</span><span class="p">):</span> <span class="s2">&quot;u32&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint16&quot;</span><span class="p">):</span> <span class="s2">&quot;u16&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">):</span> <span class="s2">&quot;u8&quot;</span><span class="p">,</span>
            <span class="c1"># numpy.dtype(&#39;bool&#39;):   &#39;bool&#39;,  # optional support</span>
            <span class="c1"># FIXME: add complex version</span>
        <span class="p">}</span>

        <span class="n">method_suffix</span> <span class="o">=</span> <span class="n">dtype_method_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method_suffix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported dtype: </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">method_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;to_data_tile_with_value_</span><span class="si">{</span><span class="n">method_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Method </span><span class="si">{</span><span class="n">method_name</span><span class="si">}</span><span class="s2"> not found on tile&quot;</span><span class="p">)</span>

        <span class="n">py03_data_tile</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">nodata_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">update</span><span class="p">(),</span> <span class="n">py03_data_tile</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">start_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The starting cell of the Tile.</span>
<span class="sd">        The starting cell defines the bottom-left corner of the Tile if the associated grid is not rotated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">start_id</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of cells in x direction, starting from the ``start_id``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">nx</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ny</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The number of cells in y direction, starting from the ``start_id``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">ny</span>

<div class="viewcode-block" id="Tile.corner_ids">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.corner_ids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">corner_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The ids at the corners of the Tile</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`.GridIndex`</span>
<span class="sd">            The :class:`.GridIndex` that contains the ids of the cells at</span>
<span class="sd">            the corners of the Tile in order: top-left, top-right, bottom-right, bottom-left</span>
<span class="sd">            (assuming the assicaited grid is not rotated)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">corner_ids</span><span class="p">())</span></div>


<div class="viewcode-block" id="Tile.corners">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.corners">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">corners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The coordinates at the corners of the Tile in order: top-left, top-right, bottom-right, bottom-left</span>
<span class="sd">        (assuming the assicaited grid is not rotated)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `numpy.ndarray`</span>
<span class="sd">            A two-dimensional array that contais the x and y coordinates of the corners</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">corners</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The ids of all cells in the Tile.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`.GridIndex`</span>
<span class="sd">            The :class:`.GridIndex` that contains the indices in the Tile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">indices</span><span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mpl_extent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Raster Bounds</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`tuple`</span>
<span class="sd">            The extent of the data as defined expected by matplotlib in (left, right, bottom, top) or equivalently (min-x, max-x, min-y, max-y)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corners</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">corners</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
            <span class="n">corners</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
            <span class="n">corners</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
            <span class="n">corners</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Tile.intersects">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.intersects">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Only checks bounds, not grid type, alignment etc.&quot;&quot;&quot;</span>
        <span class="c1"># TODO: Do check CRS</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="n">other_tile</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">get_tile</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tile</span><span class="p">):</span>
            <span class="n">other_tile</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_tile</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">PyO3Tile</span><span class="p">):</span>
            <span class="n">other_tile</span> <span class="o">=</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot determine intersection between </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other_tile</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tile.centroid">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.centroid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">index</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tile.overlap">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.overlap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">is_aligned</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">is_aligned_with</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_aligned</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AlignmentError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot find overlap of grids that are not aligned. Reason for misalignemnt: </span><span class="si">{</span><span class="n">reason</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Tile</span><span class="o">.</span><span class="n">from_pyo3_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_tile</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tile.to_shapely">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.to_shapely">[docs]</a>
    <span class="nd">@validate_index</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_shapely</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">as_multipolygon</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Refer to parent method :meth:`.BaseGrid.to_shapely`</span>

<span class="sd">        Difference with parent method:</span>
<span class="sd">            `index` is optional.</span>
<span class="sd">            If `index` is None (default) the cells containing data are used as the `index` argument.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`.BaseGrid.to_shapely`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">to_shapely</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">as_multipolygon</span><span class="o">=</span><span class="n">as_multipolygon</span><span class="p">)</span></div>


<div class="viewcode-block" id="Tile.tile_id_to_grid_id">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.tile_id_to_grid_id">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tile_id_to_grid_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oob_value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the index referring to a cell from the tile reference frame to that of the grid.</span>
<span class="sd">        The tile id follows the numpy convention and is in the form [[y0, y1, y2], [x0, x1, x2]].</span>
<span class="sd">        The grid id is int the form [(x0, y0), (x1,y1), (x2, y2)].</span>
<span class="sd">        The tile id will start at the top-left at [0,0]. The grid id starts at the bottom left,</span>
<span class="sd">        but depending on where in the world the tile is placed it can have any starting value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tile_id: Tuple</span>
<span class="sd">            The tile index in the format: ((y0, y1, y2), (x0, x1, x2)).</span>
<span class="sd">            If None, return a GridIndex that includes all cells in the tile.</span>
<span class="sd">        oob_value: int</span>
<span class="sd">            The value to assign to indices not in the tile. Default: maximum numpy.in64 value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`.GridIndex`</span>
<span class="sd">            The index referring to the same cell but in grid coordinates instead of tile coordinates</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Let&#39;s first start by creating a data_tile that we can sample using either grid ids or tile ids.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; import numpy</span>
<span class="sd">            &gt;&gt;&gt; from gridkit import RectGrid, Tile</span>
<span class="sd">            &gt;&gt;&gt; grid = RectGrid(size=5)</span>
<span class="sd">            &gt;&gt;&gt; nx = ny = 4</span>
<span class="sd">            &gt;&gt;&gt; tile = Tile(grid, start_id=(2,3), nx=nx, ny=ny)</span>
<span class="sd">            &gt;&gt;&gt; data = numpy.arange(ny*nx).reshape(ny,nx) # Note that numpy indexes in the form (y,x)</span>
<span class="sd">            &gt;&gt;&gt; data_tile = tile.to_data_tile(data=data)</span>
<span class="sd">            &gt;&gt;&gt; print(data_tile.to_numpy())</span>
<span class="sd">            [[ 0  1  2  3]</span>
<span class="sd">             [ 4  5  6  7]</span>
<span class="sd">             [ 8  9 10 11]</span>
<span class="sd">             [12 13 14 15]]</span>
<span class="sd">            &gt;&gt;&gt; tile_ids = ((1,2,3), (2,1,0))</span>
<span class="sd">            &gt;&gt;&gt; grid_ids = data_tile.tile_id_to_grid_id(tile_ids)</span>
<span class="sd">            &gt;&gt;&gt; print(grid_ids.index)</span>
<span class="sd">            [[4 5]</span>
<span class="sd">             [3 4]</span>
<span class="sd">             [2 3]]</span>

<span class="sd">        ..</span>

<span class="sd">        Note the differnce in value due to the tile&#39;s start_id of (2,3), as well as the difference in array shape.</span>

<span class="sd">        The method `tile_id_to_grid_id` exists on both Tile and DataTile objects.</span>
<span class="sd">        The tile and data_tile here are at the same location on the grid,</span>
<span class="sd">        the difference is just that the data_tile has data.</span>
<span class="sd">        Doing the id conversion should yield the same result in both cases.</span>

<span class="sd">        The value obtained from data_tile.value using the grid_id should be the same as obtaining</span>
<span class="sd">        the value from data_tile.to_numpy() using the tile_ids.</span>
<span class="sd">        You can shorthand this by just indexing directly on the data_tile.</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; assert grid_ids == tile.tile_id_to_grid_id(tile_ids)</span>
<span class="sd">            &gt;&gt;&gt; print(data_tile[tile_ids])</span>
<span class="sd">            [ 6  9 12]</span>
<span class="sd">            &gt;&gt;&gt; print(data_tile.value(grid_ids))</span>
<span class="sd">            [ 6  9 12]</span>

<span class="sd">        ..</span>

<span class="sd">        We should of course be able to get the tile_ids back using :meth:`Tile.grid_id_to_tile_id`:</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            &gt;&gt;&gt; reverted_tile_ids = tile.grid_id_to_tile_id(grid_ids)</span>
<span class="sd">            &gt;&gt;&gt; print(reverted_tile_ids)</span>
<span class="sd">            (array([1, 2, 3]), array([2, 1, 0]))</span>
<span class="sd">            &gt;&gt;&gt; numpy.testing.assert_allclose(tile_ids, reverted_tile_ids)</span>

<span class="sd">        ..</span>

<span class="sd">        # We get a tuple of numpy arrays back instead of a tuple of tuples,</span>
<span class="sd">        # but numerically they are the same as the tuple we started with.</span>
<span class="sd">        # :meth:`Tile.grid_id_to_tile_id` always returns a tuple of arrays but</span>
<span class="sd">        # :meth:`Tile.tile_id_to_grid_id` accepts a tuple of lists, tuple of tuples or tuple of arrays.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`Tile.grid_id_to_tile_id`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tile_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tile_id</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tile_id</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tile_id</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">                Expected the first dimension of tile_id to have a length of two (for x,y). Got indices in shape: </span><span class="si">{</span><span class="n">tile_id</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.</span>
<span class="s2">                This is different than the grid ids where we expect xy to be the last dimesnion.</span>
<span class="s2">                This is in an effort to make indexing the data as a numpy array using data[tuple(numpy_ids)] the same</span>
<span class="s2">                as querying values from datatile.value using grid ids botained through tile_id_to_grid_id(numpy_ids).</span>
<span class="s2">                Note that not only does this function need the first demension to be of size two,</span>
<span class="s2">                but numpy starts with the y-coordinate, so we expect: [[y0,y1,y2], [x0,x1,x2]].</span>
<span class="s2">            &quot;&quot;&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">tile_id</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">tile_id</span> <span class="o">=</span> <span class="n">tile_id</span><span class="p">[</span><span class="n">numpy</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Note: transpose to get the data from shape [[y0,y1,y2], [x0,x1,x2]]</span>
            <span class="c1">#       into shape [[x0,y0], [x1,y1], [x2,y2]] which is what the rust package works with</span>
            <span class="n">tile_id</span> <span class="o">=</span> <span class="n">tile_id</span><span class="o">.</span><span class="n">T</span>
        <span class="n">oob_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">oob_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">tile_id_to_grid_id</span><span class="p">(</span><span class="n">tile_id</span><span class="p">,</span> <span class="n">oob_value</span><span class="o">=</span><span class="n">oob_value</span><span class="p">))</span></div>


<div class="viewcode-block" id="Tile.grid_id_to_tile_id">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.Tile.grid_id_to_tile_id">[docs]</a>
    <span class="nd">@validate_index</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">grid_id_to_tile_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oob_value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the index referring to a cell from the grid reference frame to that of the tile.</span>
<span class="sd">        The tile id follows the numpy convention and is in the form [[y0, y1, y2], [x0, x1, x2]].</span>
<span class="sd">        The grid id is int the form [(x0, y0), (x1,y1), (x2, y2)].</span>
<span class="sd">        The tile id will start at the top-left at [0,0]. The grid id starts at the bottom left,</span>
<span class="sd">        but depending on where in the world the tile is placed it can have any starting value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index: :class:`.GridIndex`</span>
<span class="sd">            The grid index in the form [(x0, y0), (x1,y1), (x2, y2)].</span>
<span class="sd">            If None, return the tile indices for each cell. Note that they are in raveled form.</span>
<span class="sd">        oob_value: int</span>
<span class="sd">            The value to assign to indices not in the tile. Default: maximum numpy.in64 value.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`.GridIndex`</span>
<span class="sd">            The index referring to the same cell but in tile coordinates instead of tile coordinates</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        For an elaborate example showing going from tile_id to grid_id and back, see :meth:`Tile.tile_id_to_grid_id`</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :meth:`Tile.tile_id_to_grid_id`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">index</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">index</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="p">)</span>
        <span class="n">oob_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">oob_value</span><span class="p">)</span>
        <span class="c1"># Note: return a tuple instead of numpy array becuase numpy indexing behaviour</span>
        <span class="c1">#       is different when using arrays of integers compared to tuples.</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">grid_id_to_tile_id</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">oob_value</span><span class="o">=</span><span class="n">oob_value</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="DataTile">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">DataTile</span><span class="p">(</span><span class="n">Tile</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tile</span><span class="p">:</span> <span class="n">Tile</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected a 2D array, got </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2"> dimensions&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tile</span><span class="o">.</span><span class="n">ny</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">tile</span><span class="o">.</span><span class="n">nx</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of the data </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> does not match the shape of the tile: </span><span class="si">{</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="w"> </span><span class="n">tile</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">nodata_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">get_value_dtype</span><span class="p">(</span><span class="n">nodata_value</span><span class="p">)</span> <span class="o">==</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nodata_value</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s2">&quot;safe&quot;</span>
                    <span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Data type of the supplied array in argument &#39;data&#39; (dtype: &#39;</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&#39;) did not match the supplied nodata value &#39;</span><span class="si">{</span><span class="n">nodata_value</span><span class="si">}</span><span class="s2">&#39; of type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">nodata_value</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">grid</span>

        <span class="c1"># Map numpy dtypes to method suffixes</span>
        <span class="n">dtype_method_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">):</span> <span class="s2">&quot;f64&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">):</span> <span class="s2">&quot;f32&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">):</span> <span class="s2">&quot;i64&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">):</span> <span class="s2">&quot;i32&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int16&quot;</span><span class="p">):</span> <span class="s2">&quot;i16&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int8&quot;</span><span class="p">):</span> <span class="s2">&quot;i8&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint64&quot;</span><span class="p">):</span> <span class="s2">&quot;u64&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint32&quot;</span><span class="p">):</span> <span class="s2">&quot;u32&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint16&quot;</span><span class="p">):</span> <span class="s2">&quot;u16&quot;</span><span class="p">,</span>
            <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">):</span> <span class="s2">&quot;u8&quot;</span><span class="p">,</span>
            <span class="c1"># numpy.dtype(&#39;bool&#39;):   &#39;bool&#39;,  # optional support</span>
            <span class="c1"># FIXME: add complex version</span>
        <span class="p">}</span>
        <span class="n">method_suffix</span> <span class="o">=</span> <span class="n">dtype_method_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method_suffix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported dtype: </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;to_data_tile_</span><span class="si">{</span><span class="n">method_suffix</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">_tile</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Method </span><span class="si">{</span><span class="n">method_name</span><span class="si">}</span><span class="s2"> not found on tile&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nodata_value</span><span class="p">)</span>

        <span class="c1"># _tile is used by the Tile parent class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">get_tile</span><span class="p">()</span>

<div class="viewcode-block" id="DataTile.from_bounds_as_rect">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.from_bounds_as_rect">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_bounds_as_rect</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nodata_value</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a DataTile given a 2D numpy array on a rectangular grid.</span>
<span class="sd">        The location of the data is defined by the `bounds` paramter.</span>
<span class="sd">        The grid attributes such as the cell size are infered from the restrictions created</span>
<span class="sd">        by the dimensions of the data and the space available in the bounds.</span>

<span class="sd">        This approach assumes the bounding box, and by extension the created DataTile, is not rotated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data: class:`numpy.ndarray`</span>
<span class="sd">            A 2D array with the data for the DataTile</span>
<span class="sd">        bounds: `tuple(minx, miny, maxx, maxy)`</span>
<span class="sd">            The bounding box describing the location of the edges of the data in (minx, miny, maxx, maxy).</span>
<span class="sd">            If None, the dimensions of the `data` array will be used, resulting in a dx and dy of 1</span>
<span class="sd">            and the lower left corner of the Tile at the origin: (0,0).</span>
<span class="sd">        nodata_value:</span>
<span class="sd">            A cell with this value is considered to be empty.</span>
<span class="sd">            If None, a default will be chosen based on the dtype of the `data` array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        class:`.DataTile`</span>
<span class="sd">            A DataTile containing the suplied data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a numpy array with two dimensions.&quot;</span><span class="p">)</span>

        <span class="n">nx</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bounds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">nx</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">ny</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">RectGrid</span><span class="p">(</span><span class="n">dx</span><span class="o">=</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="o">=</span><span class="n">dy</span><span class="p">)</span>
        <span class="n">start_cell_centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">anchor</span><span class="p">(</span><span class="n">start_cell_centroid</span><span class="p">,</span> <span class="n">cell_element</span><span class="o">=</span><span class="s2">&quot;centroid&quot;</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">start_id</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_at_point</span><span class="p">(</span><span class="n">start_cell_centroid</span><span class="p">)</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">Tile</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">start_id</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tile</span><span class="o">.</span><span class="n">to_data_tile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataTile.from_interpolated_points">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.from_interpolated_points">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_interpolated_points</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;linear&quot;</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a DataTile based on the supplied `grid` that encapsulates the supplied `points`</span>
<span class="sd">        and assignes values to cells based on interpolated `values`. The size and location of the</span>
<span class="sd">        Tile are determined by the extent of the supplied `points`.</span>

<span class="sd">        .. Note ::</span>
<span class="sd">            This function is significantly slower than :meth:`.DataTile.interpolate`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid: class:`.BaseGrid`</span>
<span class="sd">            The grid on which to interpolate the data</span>
<span class="sd">        points: `numpy.ndarray`</span>
<span class="sd">            A 2d numpy array containing the points in the form [[x1,y1], [x2,y2]]</span>
<span class="sd">        values: `numpy.ndarray`</span>
<span class="sd">            The values corresponding to the supplied `points`, used as input for interpolation</span>
<span class="sd">        method: :class:`str`</span>
<span class="sd">            The interpolation method to be used. Options are (&quot;nearest&quot;, &quot;linear&quot;, &quot;cubic&quot;). Default: &quot;linear&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`.DataTile`</span>
<span class="sd">            A DataTile based on the supplied grid where the data is interpolated between the supplied points.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:meth:`.BoundedGrid.resample`</span>
<span class="sd">        :py:meth:`.BoundedGrid.interpolate`</span>
<span class="sd">        :py:meth:`.Grid.interp_from_points`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">method_lut</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">nearest</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">NearestNDInterpolator</span><span class="p">,</span>
            <span class="n">linear</span><span class="o">=</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">LinearNDInterpolator</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">nodata_value</span>
            <span class="p">),</span>
            <span class="n">cubic</span><span class="o">=</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
                <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">CloughTocher2DInterpolator</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">nodata_value</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">method_lut</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not supported. Supported methods: </span><span class="si">{</span><span class="n">method_lut</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">cells</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">cell_at_point</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="n">start_id</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">cells</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
            <span class="n">cells</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
        <span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">cells</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">tile</span> <span class="o">=</span> <span class="n">Tile</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">start_id</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>

        <span class="n">interp_func</span> <span class="o">=</span> <span class="n">method_lut</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">nodata_value</span><span class="p">):</span>
            <span class="n">nodata_mask</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nodata_mask</span> <span class="o">=</span> <span class="n">values</span> <span class="o">!=</span> <span class="n">nodata_value</span>

        <span class="n">interpolator</span> <span class="o">=</span> <span class="n">interp_func</span><span class="p">(</span>
            <span class="n">points</span><span class="p">[</span><span class="n">nodata_mask</span><span class="p">],</span>
            <span class="n">values</span><span class="p">[</span><span class="n">nodata_mask</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="n">centroids</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>

        <span class="n">interp_values</span> <span class="o">=</span> <span class="n">interpolator</span><span class="p">(</span><span class="n">centroids</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">interp_values</span><span class="p">,</span> <span class="n">nodata_value</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dtype_method_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;PyO3DataTileF64&quot;</span><span class="p">:</span> <span class="s2">&quot;float64&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PyO3DataTileF32&quot;</span><span class="p">:</span> <span class="s2">&quot;float32&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PyO3DataTileI64&quot;</span><span class="p">:</span> <span class="s2">&quot;int64&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PyO3DataTileI32&quot;</span><span class="p">:</span> <span class="s2">&quot;int32&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PyO3DataTileI16&quot;</span><span class="p">:</span> <span class="s2">&quot;int16&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PyO3DataTileI8&quot;</span><span class="p">:</span> <span class="s2">&quot;int8&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PyO3DataTileU64&quot;</span><span class="p">:</span> <span class="s2">&quot;uint64&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PyO3DataTileU32&quot;</span><span class="p">:</span> <span class="s2">&quot;uint32&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PyO3DataTileU16&quot;</span><span class="p">:</span> <span class="s2">&quot;uint16&quot;</span><span class="p">,</span>
            <span class="s2">&quot;PyO3DataTileU8&quot;</span><span class="p">:</span> <span class="s2">&quot;uint8&quot;</span><span class="p">,</span>
            <span class="c1"># numpy.dtype(&#39;bool&#39;):   &#39;bool&#39;,  # optional support</span>
            <span class="c1"># FIXME: add complex version</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">dtype_method_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>

<div class="viewcode-block" id="DataTile.astype">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.astype">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c1"># Note: Do not make unnesecary copy here, but conversion does return copy.</span>
            <span class="c1">#       Too inconsistent? Or worth skipping the copy?</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nodata_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Note, maybe obsolete if nodata_value ever is allowed to be None?</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                    <span class="n">new_nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">elif</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                    <span class="n">new_nodata_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Unable to convert nodata_value of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata_value</span><span class="si">}</span><span class="s2"> to dtype </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">new_data</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">new_nodata_value</span><span class="p">)</span>
        <span class="c1"># Note: since self and result have the same tile coverage it is safe to index result with ids from self</span>
        <span class="n">result</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata_cells</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_nodata_value</span>
        <span class="k">return</span> <span class="n">result</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodata_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">nodata_value</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@nodata_value</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodata_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the nodata value of the DataTile.</span>
<span class="sd">        This replaces all instances of the nodata value with the new value&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">set_nodata_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">get_value_dtype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">set_nodata_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<div class="viewcode-block" id="DataTile.is_nodata">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.is_nodata">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_nodata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">is_nodata</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">is_nodata_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nodata_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">nodata_cells</span><span class="p">())</span>

<div class="viewcode-block" id="DataTile.from_pyo3_data_tile">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.from_pyo3_data_tile">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_pyo3_data_tile</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pyo3_data_tile</span><span class="p">):</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">Tile</span><span class="p">(</span>
            <span class="n">grid</span><span class="p">,</span> <span class="n">pyo3_data_tile</span><span class="o">.</span><span class="n">start_id</span><span class="p">(),</span> <span class="n">pyo3_data_tile</span><span class="o">.</span><span class="n">nx</span><span class="p">(),</span> <span class="n">pyo3_data_tile</span><span class="o">.</span><span class="n">ny</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">pyo3_data_tile</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">data_tile</span> <span class="o">=</span> <span class="n">DataTile</span><span class="p">(</span>
            <span class="n">tile</span><span class="p">,</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">nodata_value</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pyo3_data_tile</span><span class="o">.</span><span class="n">nodata_value</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">data_tile</span></div>


<div class="viewcode-block" id="DataTile.to_numpy">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.to_numpy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_numpy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">GridIndex</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_id_to_tile_id</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()[</span><span class="n">item</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Don&#39;t use update() but replace _data_tile in-place</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">GridIndex</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_id_to_tile_id</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="n">new_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">new_data</span><span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">TriGrid</span><span class="p">):</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">PyO3Tile</span><span class="o">.</span><span class="n">from_tri_grid</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">_grid</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_id</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">RectGrid</span><span class="p">):</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">PyO3Tile</span><span class="o">.</span><span class="n">from_rect_grid</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">_grid</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_id</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">HexGrid</span><span class="p">):</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">PyO3Tile</span><span class="o">.</span><span class="n">from_hex_grid</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">_grid</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_id</span><span class="o">.</span><span class="n">index</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrecognized grid type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">new_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_data_tile</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata_value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span> <span class="o">=</span> <span class="n">new_data_tile</span><span class="o">.</span><span class="n">_data_tile</span>

<div class="viewcode-block" id="DataTile.update">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ny</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="c1"># TODO: Make clear that update copies the data</span>
        <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">start_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_id</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start_id</span><span class="p">,</span> <span class="n">GridIndex</span><span class="p">):</span>
                <span class="n">start_id</span> <span class="o">=</span> <span class="n">start_id</span><span class="o">.</span><span class="n">index</span>
        <span class="n">start_id</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">start_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span>
        <span class="k">if</span> <span class="n">ny</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span>
        <span class="k">if</span> <span class="n">nodata_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nodata_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata_value</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ny</span><span class="p">,</span> <span class="n">nx</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The shape of the supplied data (</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">) does not match the shape of the tile where ny is </span><span class="si">{</span><span class="n">ny</span><span class="si">}</span><span class="s2"> and nx is </span><span class="si">{</span><span class="n">nx</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataTile</span><span class="p">(</span><span class="n">Tile</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">start_id</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">),</span> <span class="n">data</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataTile.get_tile">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.get_tile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_tile</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A Tile object with the same properties as this DataTile, but without the data attached.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ny</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataTile.corner_ids">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.corner_ids">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">corner_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The ids at the corners of the Tile</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`.GridIndex`</span>
<span class="sd">            The :class:`.GridIndex` that contains the ids of the cells at</span>
<span class="sd">            the corners of the Tile in order: top-left, top-right, bottom-right, bottom-left</span>
<span class="sd">            (assuming the assicaited grid is not rotated)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">corner_ids</span><span class="p">())</span></div>


<div class="viewcode-block" id="DataTile.crop">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.crop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crop_tile</span><span class="p">):</span>
        <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">crop</span><span class="p">(</span><span class="n">crop_tile</span><span class="o">.</span><span class="n">_tile</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">cropped</span> <span class="o">=</span> <span class="n">DataTile</span><span class="p">(</span><span class="n">crop_tile</span><span class="p">,</span> <span class="n">_data_tile</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">cropped</span></div>


<div class="viewcode-block" id="DataTile.value">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.value">[docs]</a>
    <span class="nd">@validate_index</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oob_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">oob_value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">oob_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">numpy</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="n">oob_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">oob_value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>

        <span class="n">original_shape</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">index</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="k">if</span> <span class="n">index</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">index</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">index</span>
        <span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">oob_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataTile.intersects">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.intersects">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_tile</span><span class="p">()</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">other</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_linear_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">sample_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sample_points</span> <span class="o">=</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">original_shape</span> <span class="o">=</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">original_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected the last axis of sample_points to have two elements (x,y). Got </span><span class="si">{</span><span class="n">original_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> elements&quot;</span>
            <span class="p">)</span>
        <span class="n">sample_points</span> <span class="o">=</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">linear_interpolation</span><span class="p">(</span><span class="n">sample_points</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_inverse_distance_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_points</span><span class="p">,</span> <span class="n">decay_constant</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">inverse_distance_interpolation</span><span class="p">(</span>
            <span class="n">sample_points</span><span class="p">,</span> <span class="n">decay_constant</span>
        <span class="p">)</span>

<div class="viewcode-block" id="DataTile.interpolate">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.interpolate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">interpolate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">sample_points</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">,</span> <span class="s2">&quot;inverse_distance&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">interp_kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate the value at the location of ``sample_points``.</span>

<span class="sd">        Points that are outside of the bounds of the tile are assigned `self.nodata_value`, or &#39;NaN&#39; if no nodata value is set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_points: :class:`numpy.ndarray`</span>
<span class="sd">            The coordinates of the points at which to sample the data</span>
<span class="sd">        method: :class:`str`, `&#39;nearest&#39;, &#39;bilinear&#39;`, optional</span>
<span class="sd">            The interpolation method used to determine the value at the supplied `sample_points`.</span>
<span class="sd">            Supported methods:</span>
<span class="sd">            - &quot;nearest&quot;, for nearest neigbour interpolation, effectively sampling the value of the data cell containing the point</span>
<span class="sd">            - &quot;bilinear&quot;, linear interpolation using the four cells surrounding the point</span>
<span class="sd">            - &quot;inverse_distance&quot;, weighted inverse distance using the 4,3,6 nearby cells surrounding the point for Rect, Hex and Rect grid respectively.</span>
<span class="sd">            Default: &quot;nearest&quot;</span>
<span class="sd">        **interp_kwargs: `dict`</span>
<span class="sd">            The keyword argument passed to the interpolation function corresponding to the specified `method`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`numpy.ndarray`</span>
<span class="sd">            The interpolated values at the supplied points</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:meth:`.BoundedGrid.resample`</span>
<span class="sd">        :py:meth:`.BaseGrid.interp_from_points`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="n">new_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">cell_at_point</span><span class="p">(</span><span class="n">sample_points</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">new_ids</span><span class="p">,</span> <span class="n">oob_value</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nodata_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bilinear&quot;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;linear&quot;</span><span class="p">:</span>
            <span class="n">return_shape</span> <span class="o">=</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear_interpolation</span><span class="p">(</span><span class="n">sample_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">return_shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;inverse_distance&quot;</span><span class="p">:</span>
            <span class="n">decay_constant</span> <span class="o">=</span> <span class="n">interp_kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;decay_constant&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">return_shape</span> <span class="o">=</span> <span class="n">sample_points</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverse_distance_interpolation</span><span class="p">(</span>
                <span class="n">sample_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">decay_constant</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">return_shape</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Resampling method &#39;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&#39; is not supported.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataTile.resample">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.resample">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alignment_grid</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">interp_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resample the grid onto another grid.</span>
<span class="sd">        This will take the locations of the grid cells of the other grid (here called ``alignment_grid``)</span>
<span class="sd">        and determine the value on these location based on the values of the original grid (``self``).</span>

<span class="sd">            The steps are as follows:</span>
<span class="sd">             1. Transform the bounds of the original data to the CRS of the alignment grid (if not already the same)</span>
<span class="sd">                No transformation is done if any of the grids has no CRS set.</span>
<span class="sd">             2. Find the cells of the alignment grid within these transformed bounds</span>
<span class="sd">             3. Find the cells of the original grid that are nearby each of the centroids of the cells found in 2.</span>
<span class="sd">                How many nearby cells are selected depends on the selected ``method``</span>
<span class="sd">             4. Interpolate the values using the supplied ``method`` at each of the centroids of the alignment grid cells selected in 2.</span>
<span class="sd">             5. Create a new bounded grid using the attributes of the alignment grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        alignment_grid: :class:`.BaseGrid`</span>
<span class="sd">            The grid with the desired attributes on which to resample.</span>
<span class="sd">            For the new data tile with the interpolated values, a tile extent will be chosen that closely matches</span>
<span class="sd">            the tile with the original data.</span>
<span class="sd">            If a :class:`.Tile` is provided, this step is skipped and the data is interpolated onto the cells of the</span>
<span class="sd">            tile as provided.</span>

<span class="sd">            .. Tip ::</span>

<span class="sd">                If the two grids don&#39;t align very well, you can play with the offset of the alignment grid to try to</span>
<span class="sd">                make it match the orignal grid a bit better. You could for example ``anchor`` a cell corner of the</span>
<span class="sd">                alignment grid to the corner of the tile like so: ``my_data_tile.resample(my_grid.anchor(my_data_tile.corners()[0], cell_element=&quot;corner&quot;))``</span>

<span class="sd">            ..</span>

<span class="sd">        method: :class:`str`, `&#39;nearest&#39;, &#39;bilinear&#39;, &#39;inverse_distance&#39;`, optional</span>
<span class="sd">            The interpolation method used to determine the value at the supplied `sample_points`.</span>
<span class="sd">            Supported methods:</span>
<span class="sd">            - &quot;nearest&quot;, for nearest neigbour interpolation, effectively sampling the value of the data cell containing the point</span>
<span class="sd">            - &quot;bilinear&quot;, linear interpolation using the 4,3,6 nearby cells surrounding the point for Rect, Hex and Rect grid respectively.</span>
<span class="sd">            - &quot;inverse_distance&quot;, weighted inverse distance using the 4,3,6 nearby cells surrounding the point for Rect, Hex and Rect grid respectively.</span>
<span class="sd">            Default: &quot;nearest&quot;</span>
<span class="sd">        **interp_kwargs: `dict`</span>
<span class="sd">            The keyword argument passed to the interpolation function corresponding to the specified `method`</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`.BoundedGrid`</span>
<span class="sd">            The interpolated values at the supplied points</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:meth:`.BoundedGrid.interpolate`</span>
<span class="sd">        :py:meth:`.BaseGrid.interp_from_points`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tile_is_given</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alignment_grid</span><span class="p">,</span> <span class="n">Tile</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tile_is_given</span><span class="p">:</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">alignment_grid</span>
            <span class="n">alignment_grid</span> <span class="o">=</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">grid</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;`crs` not set for one or both grids. Assuming both grids have an identical CRS.&quot;</span>
            <span class="p">)</span>
            <span class="n">different_crs</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">different_crs</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_exact_same</span><span class="p">(</span><span class="n">alignment_grid</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">tile_is_given</span><span class="p">:</span>
            <span class="c1"># make sure the bounds align with the grid</span>
            <span class="k">if</span> <span class="n">different_crs</span><span class="p">:</span>
                <span class="c1"># Create array that contains points around the bounds of the tile.</span>
                <span class="c1"># Then transform these points to the new CRS.</span>
                <span class="c1"># From the transformed coordinates we can determine the shape of the new bounds</span>
                <span class="n">nr_cells_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">ny</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

                <span class="n">top_left</span><span class="p">,</span> <span class="n">top_right</span><span class="p">,</span> <span class="n">bottom_right</span><span class="p">,</span> <span class="n">bottom_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corners</span><span class="p">()</span>
                <span class="n">top_x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
                <span class="n">top_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">top_right</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
                <span class="n">top_xy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">top_x</span><span class="p">,</span> <span class="n">top_y</span><span class="p">])</span>

                <span class="n">right_x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">top_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bottom_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nr_cells_y</span><span class="p">)</span>
                <span class="n">right_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">top_right</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bottom_right</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nr_cells_y</span><span class="p">)</span>
                <span class="n">right_xy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">right_x</span><span class="p">,</span> <span class="n">right_y</span><span class="p">])</span>

                <span class="n">bottom_x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bottom_left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
                <span class="n">bootom_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bottom_right</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bottom_left</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx</span><span class="p">)</span>
                <span class="n">bottom_xy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">bottom_x</span><span class="p">,</span> <span class="n">bootom_y</span><span class="p">])</span>

                <span class="n">left_x</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bottom_left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">top_left</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nr_cells_y</span><span class="p">)</span>
                <span class="n">left_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">bottom_left</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">top_left</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">nr_cells_y</span><span class="p">)</span>
                <span class="n">left_xy</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">left_x</span><span class="p">,</span> <span class="n">left_y</span><span class="p">])</span>

                <span class="n">coords</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">top_xy</span><span class="p">,</span> <span class="n">right_xy</span><span class="p">,</span> <span class="n">bottom_xy</span><span class="p">,</span> <span class="n">left_xy</span><span class="p">])</span>

                <span class="n">transformer</span> <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">always_xy</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">corners_transformed</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="o">*</span><span class="n">coords</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

                <span class="n">ids</span> <span class="o">=</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">cell_at_point</span><span class="p">(</span><span class="n">corners_transformed</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corners</span><span class="p">()</span>
                <span class="n">ids</span> <span class="o">=</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">cell_at_point</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Prevent outer rows or columns with all nodata_value.</span>
            <span class="c1"># The centroid of the corner ids in the alignment_grid are checked against</span>
            <span class="c1"># the bounds of the original tile to see if the centroid of these new corner ids</span>
            <span class="c1"># is within the original tile. If the centroid is not within the original tile</span>
            <span class="c1"># the values will always be nodata_value so we don&#39;t want to include these.</span>
            <span class="n">reference_corners</span> <span class="o">=</span> <span class="n">corners_transformed</span> <span class="k">if</span> <span class="n">different_crs</span> <span class="k">else</span> <span class="n">corners</span>
            <span class="n">total_bounds</span> <span class="o">=</span> <span class="p">(</span>  <span class="c1"># in min_x, min_y, max_x, max_y</span>
                <span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">reference_corners</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                <span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">reference_corners</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">left_new</span><span class="p">,</span> <span class="n">bottom_new</span> <span class="o">=</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">centroid</span><span class="p">([</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">])</span>
            <span class="n">right_new</span><span class="p">,</span> <span class="n">top_new</span> <span class="o">=</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">centroid</span><span class="p">([</span><span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">left_new</span> <span class="o">&lt;=</span> <span class="n">total_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">min_x</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">total_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">left_new</span><span class="p">)</span> <span class="o">/</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">bottom_new</span> <span class="o">&lt;=</span> <span class="n">total_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">min_y</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">total_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bottom_new</span><span class="p">)</span> <span class="o">/</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">right_new</span> <span class="o">&gt;=</span> <span class="n">total_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">max_x</span> <span class="o">-=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">right_new</span> <span class="o">-</span> <span class="n">total_bounds</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">top_new</span> <span class="o">&gt;=</span> <span class="n">total_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                <span class="n">max_y</span> <span class="o">-=</span> <span class="nb">int</span><span class="p">(</span>
                    <span class="n">numpy</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">top_new</span> <span class="o">-</span> <span class="n">total_bounds</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="n">tile</span> <span class="o">=</span> <span class="n">Tile</span><span class="p">(</span>
                <span class="n">alignment_grid</span><span class="p">,</span> <span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">),</span> <span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># Tile is already given</span>
            <span class="k">pass</span>  <span class="c1"># Pass because we already have a tile to interpolate on</span>

        <span class="n">new_ids</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">new_ids</span><span class="o">.</span><span class="n">shape</span>

        <span class="n">new_points</span> <span class="o">=</span> <span class="n">alignment_grid</span><span class="o">.</span><span class="n">centroid</span><span class="p">(</span><span class="n">new_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">different_crs</span><span class="p">:</span>
            <span class="n">transformer</span> <span class="o">=</span> <span class="n">Transformer</span><span class="o">.</span><span class="n">from_crs</span><span class="p">(</span>
                <span class="n">alignment_grid</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="n">always_xy</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">original_shape</span> <span class="o">=</span> <span class="n">new_points</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">raveled_new_points</span> <span class="o">=</span> <span class="n">new_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">transformed_points</span> <span class="o">=</span> <span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="o">*</span><span class="n">raveled_new_points</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">new_points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">transformed_points</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">original_shape</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">new_points</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">interp_kwargs</span><span class="p">)</span>

        <span class="c1"># If value id 1D, turn into 2D</span>
        <span class="c1"># Take into account if the 1D line of cells runs in x or y direction</span>
        <span class="k">if</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">:</span>
            <span class="n">empty_axis</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">empty_axis</span><span class="p">)</span>

        <span class="n">nodata_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata_value</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodata_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">numpy</span><span class="o">.</span><span class="n">nan</span>

        <span class="n">new_tile</span> <span class="o">=</span> <span class="n">Tile</span><span class="p">(</span>
            <span class="n">alignment_grid</span><span class="p">,</span>
            <span class="n">start_id</span><span class="o">=</span><span class="n">new_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">nx</span><span class="o">=</span><span class="n">new_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">ny</span><span class="o">=</span><span class="n">new_ids</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DataTile</span><span class="p">(</span><span class="n">new_tile</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">nodata_value</span><span class="o">=</span><span class="n">nodata_value</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataTile.to_crs">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.to_crs">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_crs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crs</span><span class="p">,</span> <span class="n">resample_method</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transforms the Coordinate Reference System (CRS) from the current CRS to the desired CRS.</span>
<span class="sd">        This will modify the cell size and the bounds accordingly.</span>

<span class="sd">        The ``crs`` attribute on the current grid must be set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crs: Union[int, str, pyproj.CRS]</span>
<span class="sd">            The value can be anything accepted</span>
<span class="sd">            by :meth:`pyproj.CRS.from_user_input() &lt;pyproj.crs.CRS.from_user_input&gt;`,</span>
<span class="sd">            such as an epsg integer (eg 4326), an authority string (eg &quot;EPSG:4326&quot;) or a WKT string.</span>
<span class="sd">        resample_method: :class:`str`</span>
<span class="sd">            The resampling method to be used for :meth:`.DataTile.resample`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~.rect_grid.BoundedRectGrid`</span>
<span class="sd">            A copy of the grid with modified cell spacing and bounds to match the specified CRS</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        Examples:</span>

<span class="sd">        :ref:`Example: coordinate transformations &lt;example coordinate transformations&gt;`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_inf_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">crs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">new_inf_grid</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">resample_method</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_add_tile</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;TypeError&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Cannot add DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;PanicException&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;overflow&quot;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Overflow encountered when adding DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`. Consider using a different data format.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_add_scalar</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot add DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>

        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_add_tile</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;TypeError&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Cannot add DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;PanicException&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;overflow&quot;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Overflow encountered when adding DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`. Consider using a different data format.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_add_scalar_reverse</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot add DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>

        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_subtract_tile</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;TypeError&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Cannot subtract DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;PanicException&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;overflow&quot;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Overflow encountered when subtracting DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`. Consider using a different data format.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_subtract_scalar</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subtract DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_subtract_tile</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;TypeError&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Cannot subtract DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;PanicException&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;overflow&quot;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Overflow encountered when subtracting DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`. Consider using a different data format.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_subtract_scalar_reverse</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot subtract DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_multiply_tile</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;TypeError&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Cannot multiply DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;PanicException&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;overflow&quot;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Overflow encountered when multiplying DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`. Consider using a different data format.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_multiply_scalar</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot multiply DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_multiply_tile</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;TypeError&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Cannot multiply DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;PanicException&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;overflow&quot;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Overflow encountered when multiplying DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`. Consider using a different data format.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_multiply_scalar_reverse</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot multiply DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_divide_tile</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;TypeError&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Cannot divide DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;PanicException&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;overflow&quot;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Overflow encountered when dividing DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`. Consider using a different data format.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_divide_scalar</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot divide DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_divide_tile</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">BaseException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;TypeError&quot;</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Cannot divide DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
                <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;PanicException&quot;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s2">&quot;overflow&quot;</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Overflow encountered when dividing DataTiles of `</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">` and `</span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">`. Consider using a different data format.&quot;</span>
                        <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_divide_scalar_reverse</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot divide DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Elementwise raising to the power between two DataTiles is not supported.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_powi</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_powf</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot divide DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Elementwise raising to the power between two DataTiles is not supported.&quot;</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">_data_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">_powf_reverse</span><span class="p">(</span><span class="n">other_converted</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot divide DataTile and `</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">`&quot;</span><span class="p">)</span>
        <span class="n">combined</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">combined</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span> <span class="o">==</span> <span class="n">other_converted</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare DataTile with object of type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span> <span class="o">!=</span> <span class="n">other_converted</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare DataTile with object of type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span> <span class="o">&gt;=</span> <span class="n">other_converted</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare DataTile with object of type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span> <span class="o">&gt;</span> <span class="n">other_converted</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare DataTile with object of type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span> <span class="o">&lt;=</span> <span class="n">other_converted</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare DataTile with object of type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">other_converted</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">GridIndex</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span> <span class="o">&lt;</span> <span class="n">other_converted</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare DataTile with object of type &#39;</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="DataTile.max">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.max">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the maximum value in the data tile, disregarding the nodata_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">max</span><span class="p">()</span></div>


<div class="viewcode-block" id="DataTile.min">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.min">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the maximum value in the data tile, disregarding the nodata_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">min</span><span class="p">()</span></div>


<div class="viewcode-block" id="DataTile.mean">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.mean">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the maximum value in the data tile, disregarding the nodata_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span></div>


<div class="viewcode-block" id="DataTile.sum">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.sum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the sum of all values in the data tile, disregarding the nodata_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span></div>


<div class="viewcode-block" id="DataTile.median">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.median">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the median value of the data tile, disregarding the nodata_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">median</span><span class="p">()</span></div>


<div class="viewcode-block" id="DataTile.percentile">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.percentile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">percentile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">percentile</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the percentile of the data tile at the specified value, disregarding the nodata_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">percentile</span><span class="p">)</span></div>


<div class="viewcode-block" id="DataTile.std">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.DataTile.std">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the standard deviation of the data in the tile, disregarding the nodata_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_tile</span><span class="o">.</span><span class="n">std</span><span class="p">()</span></div>
</div>



<div class="viewcode-block" id="combine_tiles">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.combine_tiles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">combine_tiles</span><span class="p">(</span><span class="n">tiles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a tile that covers all supplied tiles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tiles: List[Tile]</span>
<span class="sd">        A list of tiles around which the combined tile will be created.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`.Tile`</span>
<span class="sd">        A Tile that covers the supplied Tiles</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pyo3_tiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tiles</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">Tile</span><span class="p">):</span>
            <span class="n">pyo3_tiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">_tile</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="n">pyo3_tiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">_tile</span><span class="o">.</span><span class="n">_tile</span><span class="p">)</span>  <span class="c1"># Man this nesting gets rediculous</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected all Tile or DataTile objects but also got a: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="n">pyo3_tile</span> <span class="o">=</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">combine_tiles</span><span class="p">(</span><span class="n">pyo3_tiles</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Tile</span><span class="o">.</span><span class="n">from_pyo3_tile</span><span class="p">(</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">pyo3_tile</span><span class="p">)</span></div>



<div class="viewcode-block" id="count_tiles">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.count_tiles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">count_tiles</span><span class="p">(</span><span class="n">tiles</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Count how many times a cell occurs in a tile for the list of tiles provided.</span>
<span class="sd">    Regions where many tiles overlap will have a high count, regions where few tiles</span>
<span class="sd">    overlap will have low count.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tiles: `List[Tile]` or `List[DataTile]`</span>
<span class="sd">        The tiles from which the overlap count will be determined.</span>
<span class="sd">        For each Tile that is supplied in the list, all cells in the tile contribute to the count.</span>
<span class="sd">        For each DataTile that is supplied in the list, the cells with a value equal to the</span>
<span class="sd">        nodata_value of the DataTile are ignored for the count.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`.DataTile`</span>
<span class="sd">        A data tile where each value indicates by how many tiles this cell was covered.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pyo3_tiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pyo3_data_tiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">tiles</span><span class="p">:</span>
        <span class="c1"># Note: check DataTile before Tile, because DataTile is a subclass of Tile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="n">pyo3_data_tiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>  <span class="c1"># Man this nesting gets rediculous</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">Tile</span><span class="p">):</span>
            <span class="n">pyo3_tiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">_tile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected all Tile or DataTile objects but also got a: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">if</span> <span class="n">pyo3_tiles</span><span class="p">:</span>
        <span class="n">pyo3_data_tile</span> <span class="o">=</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">count_tiles</span><span class="p">(</span><span class="n">pyo3_tiles</span><span class="p">)</span>
        <span class="n">result_tiles_only</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">pyo3_data_tile</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pyo3_data_tiles</span><span class="p">:</span>
        <span class="n">pyo3_data_tile</span> <span class="o">=</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">count_data_tiles</span><span class="p">(</span><span class="n">pyo3_data_tiles</span><span class="p">)</span>
        <span class="n">result_data_tiles_only</span> <span class="o">=</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span>
            <span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">pyo3_data_tile</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">pyo3_tiles</span> <span class="ow">and</span> <span class="n">pyo3_data_tiles</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result_tiles_only</span> <span class="o">+</span> <span class="n">result_data_tiles_only</span>
        <span class="c1"># Note: After summation, nodata values are added in the corners where no tiles are present</span>
        <span class="c1">#       if the DataTiles do not have the exact same coverage as the supplied Tiles.</span>
        <span class="c1">#       Since we want a count to say 0 where no tile is present, we replace the nans</span>
        <span class="c1">#       introduced by the summation with zeros.</span>
        <span class="n">result</span><span class="p">[</span><span class="o">~</span><span class="n">numpy</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">result</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">if</span> <span class="n">pyo3_tiles</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result_tiles_only</span>
    <span class="k">if</span> <span class="n">pyo3_data_tiles</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result_data_tiles_only</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;No Tiles were found in the arguments&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="sum_data_tiles">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.sum_data_tiles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sum_data_tiles</span><span class="p">(</span><span class="n">data_tiles</span><span class="p">:</span> <span class="n">List</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add the DataTiles in the data_tiles list. Nodata_values will be ignored.</span>
<span class="sd">    Each cell will then contain the sum of the value that cell accross the supplied DataTiles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_tiles: `List[Tile]` or `List[DataTile]`</span>
<span class="sd">        A list of DataTiles to add together.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`.DataTile`</span>
<span class="sd">        A data tile with the values of the provided data_tiles added together</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_tiles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No data tiles were supplied&quot;</span><span class="p">)</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="n">data_tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">is_aligned_with</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">data_tiles</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="n">AlignmentError</span><span class="p">(</span>
            <span class="s2">&quot;Not all data tiles are on the same grid. Consider resampling them all to the same grid.&quot;</span>
        <span class="p">)</span>

    <span class="n">result_dtype</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">data_tiles</span><span class="p">)</span>
    <span class="n">pyo3_tiles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="n">data_tiles</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">DataTile</span><span class="p">):</span>
            <span class="n">pyo3_tiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">_data_tile</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected all DataTile objects but also got a: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="n">dtype_method_map</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;float64&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_f64</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_f32</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int64&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_i64</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int32&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_i32</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int16&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_i16</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;int8&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_i8</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint64&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_u64</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint32&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_u32</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint16&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_u16</span><span class="p">,</span>
        <span class="n">numpy</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;uint8&quot;</span><span class="p">):</span> <span class="n">tile_utils</span><span class="o">.</span><span class="n">sum_data_tile_u8</span><span class="p">,</span>
        <span class="c1"># numpy.dtype(&#39;bool&#39;):   &#39;bool&#39;,  # optional support</span>
        <span class="c1"># FIXME: add complex version</span>
    <span class="p">}</span>

    <span class="n">method</span> <span class="o">=</span> <span class="n">dtype_method_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">result_dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported dtype: </span><span class="si">{</span><span class="n">result_dtype</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">pyo3_data_tile</span> <span class="o">=</span> <span class="n">method</span><span class="p">(</span><span class="n">pyo3_tiles</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DataTile</span><span class="o">.</span><span class="n">from_pyo3_data_tile</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pyo3_data_tile</span><span class="p">)</span></div>



<div class="viewcode-block" id="average_data_tiles">
<a class="viewcode-back" href="../../api/gridkit.tile.html#gridkit.tile.average_data_tiles">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">average_data_tiles</span><span class="p">(</span><span class="n">data_tiles</span><span class="p">:</span> <span class="n">List</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Average the DataTiles in the data_tiles list. Nodata_values will be ignored.</span>
<span class="sd">    Each cell will then contain the mean or average value of that cell accross the supplied DataTiles.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_tiles: `List[Tile]` or `List[DataTile]`</span>
<span class="sd">        A list of DataTiles to average.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    :class:`.DataTile`</span>
<span class="sd">        A data tile with the averaged values of the provided data_tiles</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Simply calling `return sum(tiles) / count(tiles)` is a lot shorter, but I want to use the rust</span>
    <span class="c1"># logic such that the rust and python logic are the same and don&#39;t have possible inconsistencies</span>
    <span class="c1"># like inf instead of nan or vice versa. I want just one place for the logic.</span>
    <span class="n">summed</span> <span class="o">=</span> <span class="n">sum_data_tiles</span><span class="p">(</span><span class="n">data_tiles</span><span class="p">)</span>
    <span class="n">counted</span> <span class="o">=</span> <span class="n">count_tiles</span><span class="p">(</span><span class="n">data_tiles</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">summed</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">summed</span> <span class="o">/</span> <span class="n">counted</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Timo Millenaar.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>

      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <style>
    .rst-other-versions li.current a {
      font-weight: bold;
      color: #007bff;
    }
  </style>
  <span class="rst-current-version" data-toggle="rst-current-version">
    Version: dev
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions">
    
    <dl>
      <dt>Versions</dt>
      
        <li class="current">
          <a href="GridKit/versions/dev//index.html">dev</a>   <--
        </li>
      
        <li >
          <a href="GridKit/versions/v0.14.1//index.html">v0.14.1</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.14.0//index.html">v0.14.0</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.13.0//index.html">v0.13.0</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.12.1//index.html">v0.12.1</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.12.0//index.html">v0.12.0</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.11.1//index.html">v0.11.1</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.11.0//index.html">v0.11.0</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.10.0//index.html">v0.10.0</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.9.2//index.html">v0.9.2</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.9.1//index.html">v0.9.1</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.9.0//index.html">v0.9.0</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.8.0//index.html">v0.8.0</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.7.3//index.html">v0.7.3</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.7.2//index.html">v0.7.2</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.7.1//index.html">v0.7.1</a> 
        </li>
      
        <li >
          <a href="GridKit/versions/v0.7.0//index.html">v0.7.0</a> 
        </li>
      
    </dl>
    
    <br>
    </dl>
  </div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>